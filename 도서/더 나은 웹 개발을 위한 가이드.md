# 네이티브 앱의 시대는 저물까?
[2023년 통계](https://www.zippia.com/advice/mobile-vs-desktop-usage-statistics/)에 따르면 "전 **세계 웹사이트 트래픽의 60%는** 모바일 기기에서 나온다."라고 한다.
테슬라 전기차 대시보드에는 웹 브라우저가 포함되어 있다. 테슬라 전기차의 OS는 잘 모르겠지만, (아마도 안드로이드?) 애플카가 나온다면 iOS나 MacOS처럼 애플만의 OS가 들어가겠지.
그럼 자동차에 들어가는 앱을 만든다면, OS별로 별도의 앱을 구축해야할 것이다.
웹은 OS마다 별도로 개발할 필요가 없고, 일부 조정만 필요하기 때문에 플러터 같은 언어로 개발하는 것이 훨씬 효율적일 것이다.

# 웹 개발 라이프 사이클
1. 정보 수집
	- 고객 요구 사항 파악
	- 유사 서비스 벤치마킹
	- 아이템 선정 : 어떤 제품을 만들어서 어떤 서비스를 제공할 것인지 결정
2. 기획
	 - 개발의 위한 팀 구성
	- 개발을 위한 기술 스택 및 소프트웨어 개발 방법론 선택
	- 사이트맵을 통한 웹 애플리케이션 메뉴 결정
	- 개발 일정 및 리소스 할당 계획 수립
	- 브랜딩 전략 수립
3. 디자인
4. 콘텐츠 생성
5. 개발
6. 테스트 및 품질 보증
7. 배포 및 운영

# 개발자의 역량
p.36 "지금까지의 웹 기획은 웹 기획자나 ··· 담당하는 영역이었습니다. 하지만 앞으로의 개발자는 ··· **웹 애플리케이션이 어떤 목적으로 누구를 위해 설계되고 향후 어떻게 발전해 나갈 것인지에 대해 알고 있는 개발자와 그렇지 못한 개발자 사이에는 큰 격차가 생길 수 밖에 없습니다.** "

## 잘 읽히는 웹과 그렇지 못한 웹
- 잘 읽히는 웹 : 간단 명료하게 작성하라.
	- 마크업을 작성할 때 불필요한 태그는 제거해야한다.
	- 구조가 복잡해지고 태그의 깊이가 깊어질수록 DOM 트리를 생성하는 비용이 많이 든다.
	- 정확한 의미 전달을 하는 것도 중요하다. == 시맨틱 태그를 작성하자.

## 브라우저 렌더링 최적화
### 렌더링 엔진
- 크롬 : 블링크 Blink
- 사파리 : 웹킷 Webkit
- 파이어폭스 : 게코 Gecko

[![브라우저의 구조](https://velog.velcdn.com/images/sangbin2/post/8df386d7-10ba-414e-abe3-b9f5256c41f7/image.png)

- 사용자 인터페이스 : 주소 표시줄, 이전/다음 버튼, 새로고침 버튼, 북마크 메뉴 등 웹 페이지 영역을 제외한 나머지 부분
- 브라우저 엔진 : 사용자 인터페이스와 렌더링 엔진 사이를 연결, URL 로드, 기타 상위 수준 탐색 작업 시작 방법을 제공
	- ex. 사용자가 주소창에 url을 입력하면, 해당 웹사이트 리소스를 요청하고, 렌더링 엔진을 통해 요청한 웹페이지가 나타나도록 제어한다.
- 렌더링 엔진 : 웹 페이지 표시. (html, css를 파싱하여 화면에 보여줌)
- 네트워킹 : HTTP 등을 통해 인터넷에 접근하거나 데이터를 전송함 (클라이언트-서버 간의 데이터 통신 담당)
	- 다음과 같은 사용자 액션이 있을 때마다 웹 페이지 요청이 발생
		- 브라우저 주소창에 주소를 입력하는 경우
		- 웹페이지에서 링크가 있는 요소인 메뉴, 버튼 등을 선택한 경우
		- 이전, 다음, 새로고침 버튼을 선택한 경우
		- 스크립트에서 서버 리소스를 요청한 경우
	- 동작 과정
		1. 사용자가 웹 페이지에 대한 요청을 보내면, "통신"이 DNS를 통해 실제 웹 페이지를 제공하는 웹 서버의 IP 주소를 찾음.
			(* DNS : 도메인 주소를 IP 주소로 변환)
		2. 웹서버에 요청된 페이지를 보내달라는 신호를 보냄.
		3. 요청 받은 웹 서버는 페이지에 대한 리소스(HTML, CSS, JS, 이미지 등)을 사용자 브라우저로 전송함.
		4. 전송 받은 웹 페이지 리소스를 렌더링 엔진, 자바스크립트 인터프리터로 파싱
		5. 웹페이지 표시
- 자바스크립트 해석기(인터프리터) : 자바스크립트 코드를 해석하고 실행하며 크롬에서는 V8 엔진을 사용함
	- 런타임 환경에서 기계어를 한 줄씩 번역해서 실행
	- 모든 브라우저는 자바 스크립트 엔진을 내장하고 있음.
		- 크롬 브라우저 : 구글의 V8 엔진 사용 (Node.js는 V8 엔진을 사용하며, 브라우저가 아닌 곳에서도 자바스크립트를 사용할 수 있도록 만들어졌습니다.)
	- 렌더링 엔진에서 웹 서버로부터 받은 HTML 파일을 읽다가 ``<script>``를 만나면 HTML 파싱 작업을 일시 중단하고, 자바스크립트 인터프리터가 해당 코드를 해석하고 실행합니다.
- UI 백엔드 : 브라우저에 내장되어 있는 UI 위젯을 표시함
- 자료저장소 : 로컬 스토리지, 세션 스토리지, 쿠키 등 클라이언트 측에서 데이터를 저장하는 영역

### 렌더링 과정
1. 사용자가 웹 페이지 요청
2. 웹서버로부터 필요한 리소스(HTML, CSS 등) 전송 받음
3. 렌더링 엔진이 HTML 파싱해서 DOM 트리 생성
4. HTML 파싱하다가 CSS를 만나면 렌더링을 잠시 중단하고, CSS 파싱해서 CSSDOM 트리 생성
5. HTML을 파싱하다가 자바스크립트를 만나면 HTML 파싱을 잠시 중단하고 자바스크립트 인터프리터가 자바스크립트를 해석하고 실행
6. 다시 HTML을 파싱하여 최종적으로 DOM 트리와 CSSDOM 트리를 결합해서 렌더 트리 생성
7. 렌더 트리가 생성되면, 레이아웃 단계에서 렌더 트리를 화면에 배치하기 위해 절대적인 픽셀 값 계산
8. 페인팅 단계에서 화면에 렌더 트리의 각 노드를 화면에 실제 픽셀로 변환
9.  화면에 모든 요소가 그려짐